# KillThread

Для того, щоб зупинити виконання потоку використовуємо наступні методи: 
- interrupt(); - вказує суб'єкту класу Thread, що необхідно зупинити роботу потоку. Cам метод не зупиняє роботу потоку, він лише міняє стан суб'єкту (міняє мітку з дефолтного значення false на true); 
- isInterrupted() - перевіряє в якому стані знаходиться об’єкт (повертає boolean - значення мітки) 
- interrupted() - перевіряє в якому стані знаходиться об’єкт (повертає boolean - значення мітки), після чого скидає мітку в дефолтний стан false 
 
 
Розглянемо приклад: 
<pre><strong>
Thread myThread = new Thread(new Runnable() { 
	@Override 
	public void run() {
 		Thread thread = Thread.currentThread();
 		for (int i = 0; i < 1000000000; i++) {
 			if (thread.isInterrupted()) { break; //exit }
 			Log.i(TAG_LOG, "Thread is work " + i);
  		}
 	} 
 });
 _ myThread.start();
 </strong></pre>

 
  
//Thread myThread. = new Thread(new Runnable() { - створюємо екземпляр об”єкта Thread (поток) при ініціалізації якого в конструктор передаємо анонімний клас - (new Runnable(){...}) в цьому класі перевизначений  метод public void run() {} - саме в ньому і описується робота потоку і його поведінка. Відповідно коли метод run() завершить свою роботу, то потік можна рахувати мертвим. Щоб передчасно завершити роботу метода run() - потрібно періодично перевіряти чи не викликався в даного потоку метод - interrupt(). Якщо так то завершуємо роботу методу run() - використовуючи відомі методи: break, return, або exception, все залежить від того які процес відбувається в методі run(); 
 
//оскільки з тіла анонімного класу прямого доступу до змінної myThread. у нас немає, відповідно перевірити чи викликався метод .interrupt() не можливо, і тут нам на допомогу приходить Thread.currentThread() - що повертає посилання на об'єкт myThread.. Дану силку ми присвоюємо новому об'єкту Thread thread = Thread.currentThread();. Фактично ми отримали дві змінні які ведуть на один і той же об'єкт в пам'яті (thread  рівний myThread. ). 

//if (thread.isInterrupted()) { break; //exit } - тепер методом isInterrupted() ми можемо перевірити чи викликався метод interrupt(), якщо true - ми руйнуємо довгограючий цикл і робота методу run() завершуєтесь. (оскільки в ньому крутиться лише один цикл. Процедуру виходу із метода run() слід  ретельно продумувати, в залежності від задач які виконуються в  методі run() )
 
 
 


